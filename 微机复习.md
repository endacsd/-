**《微机系统》练习题**

 

 

1. 微处理器、微型计算机、微型计算机系统的区别是什么？

  微处理器:CPU

  微型计算机是由CPU、 主存储器、 输入／输出接口电路和系统总线构成，

  微型计算机系统由微型计算机、输入／输出设备、外存储器、系统软件、电源、 面板和机架等组成。
2. 微型计算机有哪些基本部分构成？

  微处理器CPU,主存储器M,I/O接口，三种总线，I/O设备
3. CISC、RISC的技术特点。
    CISC是指复杂指令系统计算机，RISC是指精简指令系统计算机。
    他们的区别在于不同的CPU设计理念和方法。RISC指令系统仅包含哪些必要的经常使用的指令，不经常使用的功能，往往通过基本指令组合来完成。完成特殊功能时效率比较低。CISC的指令系统比较丰富，一些特殊功能都有相应的指令。处理特殊任务效率较高。
    RISC对存储器操作相对简单，使对存储器访问的控制简化；而CISC机器的存储器操作指令较多，对存储器的访问有更多的指令直接操作，要求的控制逻辑比较复杂。RISC在一条指令执行的适当地方可以响应中断；而CISC机器是在一条指令执行结束后响应中断。
    RISC CPU的电路构成比CISC CPU简单，因此面积小、功耗也更低；CISC电路 CPU电路复杂，同水平比RISC CPU面积大、功耗大。RISC CPU结构比较简单，布局紧凑规整，设计周期较短，比较容易采用一些并行计算的最新技术；CISC CPU结构复杂，设计周期长，技术更新难度大。从使用角度看，RISC微处理器结构简单，指令规整，性能容易把握，易学易用；CISC微处理器结构复杂，功能强大，实现特殊功能容易。
4. 8086的两种工作方式由什么决定？两种工作方式有什么差别? 
    $MN/\overline{MX}$:接+5v为最小模式，接地为最大模式
    最小模式：单机系统，只有一个8086 CPU，所有控制信号由 该CPU产生。系统中的控制电路可减到最小。
    最大模式： 多机系统，有两个以上CPU，一个主8086 CPU， 其他为协处理器（如8087、8089），控制信号由总线控制器 8288产生。
5. 8086CPU的组成与功能。
    总线接口部件BIU跟执行部件EU。
    总线接口部件（BIU）是联系微处理器内部与外部的重要通道，其主要功能是负责微处理器内部与外部的信息传递。主要任务：（1）取指令（2）形成物理地址（3）传送数据
    EU完成控制器的功能，它负责执行指令并对相应的硬件部分进行控制，它的主要功能就是完成全部指令的执行。EU完成以下主要任务：（1）指令译码（2）执行指令（3）向BIU传送偏移地址信息（4)管理通用寄存器和标志寄存器。
6. 8086微处理器有那几个段寄存器？简述他们的主要功能。

  4个，CS内容指出当前代码段，SS内容指出当前程序所使用的堆栈段，DS指出了当前程序使用的数据段，ES指出了当前程序使用的附加段。
7. 什么是物理地址、逻辑地址？逻辑地址2000:2345H对应的物理地址是多少？
    物理地址:信息在存储器中实际存放的地址，地址通过地址线给出
    逻辑地址:编程中给出的地址 [段地址:段内偏移量]
    段地址*16+段内偏移量
    物理地址=22345H

8. 若代码段寄存器CS＝3200H，指令指针IP＝0FF00H，此时，指令存放的物理地址是什么？说明指向这一物理地址的CS和IP值是否唯一。 ?
    32000H+0FF00H
    不唯一，可以有其他组合方式
9. 对齐数据与非对齐数据的不同结构对数据的访问速度的影响。
    字存放在任意连续的两个单元中，低字节放在低地址中（小 端方式），低字节对应的地址为这个字数据的地址。 • 对齐字：在偶数地址中开始存放。读写时，只需一个总线周 期。 • 非对齐字：在奇数地址中开始存放。读写时，需两个总线周期。
    当访问的数据是一个对准数据时，一个总线周期可以完成读写，如果访问的数据不是对准的数据时，要通过两个总线周期完成读写过程，因此编程时应当应尽量使数据对准存放。
10. 简述Pentium微处理器的主要性能特点。
    超标量流水线，分立Cache,浮点运算部件，动态转移预测
11. Pentium 有什么主要技术特点？至少说出四点。
同上
12. 说明Pentium处理器引脚#Cache和#KEN的作用.
    Cache：Cache控制，指示目前处于Cache周期。
    KEN：Cache允许，有效时，指示进入突发读周期，将外部数据复制到内 部Cache。
13. 说明Pentium处理器引脚＃BE7～＃BE0的作用。
    字节允许输出信号。 用千选择访问单字节、 字、 双字或四字数据。 这些信号 在微处理器内由地址知、 A 1和A 2产生。
14. 什么是指令周期？什么是总线周期？什么是时钟周期？说明三者的关系。
    时钟周期：CPU脉冲时间。
    总线周期：CPU经过总线执行信息的输入/输出过程，称为总线周期。
    指令周期：完成一条指令的时间。
    关系：一个总线周期包含多个指令周期，一个时钟周期包含多个时钟周期。
15. 说明寄存器EAX、AX、AH、AL之间的关系。
| EXA  | EXA  | AX   | AX   |
| ---- | ---- | ---- | ---- |
|      |      | AH   | AL   |

16. Pentium总线操作有几种时钟状态？T12、T2P、TD与一般的时钟状态有什么区别？
    5种
    ??
17. IP/EIP寄存器的用途是什么？
    IP/EIP内容为下一条要取入CPU的指令在内存中的偏移地址。CPU复位后，IP/EIP清零。每取一条指令，IP/EIP自动增加取入CPU的字节数目。
18. Pentium 微处理机在实模式下操作时，段寄存器的用途是什么？

  在实地址模式下，Pentium的运行方式为8086方式，CPU可以直接访问段寄存器，每个段寄存器定义一个64KB存储器段的起点，既给出相应的段基址。CS内容指出当前代码段，SS内容指出当前程序所使用的堆栈段，DS指出了当前程序使用的数据段，ES指出了当前程序使用的附加段。

19. Pentium的寄存器组包括哪些类型的寄存器？简要说明基本结构寄存器、系统级寄存器的用途。
  20. 基本结构寄存器 16个
  21. 系统级寄存器 9个
  22. 调试寄存器 8个
  23. 模型专用寄存器 20个
  5. 浮点寄存器 18个

  * 基本结构寄存器:
      - 通用结构寄存器8个： EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI ，保存算术和逻辑运算数种的操 作数，保存地址(ESP除外)
      - 专用寄存器:指令指针指示器和标志寄存器
          * EIP ，其内容时下一条要取入CPU的指令在内存中的偏移地址，当一个程序开始运行时，系统把EIP清零，每取入一条指令，EIP自动增加CPU取入CPU的字节数
          * 标志寄存器FLAGS:  状态标志，控制标志和系统标志
      - 段寄存器：
      编程可见的6个16位选择符寄存器，CS,DS,ES,SS,FS,GS，对应6个64位的描述符不可见寄存器，用来描述一个段的段基地址，段限(范围和长度)，段的属性



* 系统级寄存器:
  - 系统地址寄存器：
     * 全局描述符寄存器GDTR
     * 中断描述符寄存器IDTR
     * 局部描述符寄存器LDTR
     * 任务寄存器TR
  - 控制寄存器：
     * 控制寄存器CR0
     * 控制寄存器CR1
     * 控制寄存器CR2
     * 控制寄存器CR3
     * 控制寄存器CR4

20.  在Pentium处理器总线周期中，＃NA有效具有什么样的意义？
    NA：下一地址有效，用于支持地址流水线操作。采样到NA 有效的两个时钟周期后，CPU可送出新地址。

21. CPU与存储器连接时主要应考虑哪些问题？
  * 总线驱动能力
  * 时序配合
  * 数据线的连接
  * 读写控制线的连接
  * ROM与RAM在存储器中的地址分配
  * 对多种宽度数据访问的支持

22. 什么是高速缓存? 计算机中设置Cache的作用是什么?能不能把Cache的容量扩大，最后取代主存?
    Cache?
    提高访问内存的速度。
    不能，成本太高
23. 说明伪指令END、ENDS、ENDP、ENDM的区别。
    END程序汇编结束
    ENDS段定义结束
    ENDP过程定义结束
    ENDM宏定义结束
24. 指出下列指令的错误：
（1）MOV  AH，BX         BX,AH 位数不对
（2）ADD  15H，BX        应该位寄存器
（3）MOV  CS，AX         CS只能由系统管理
（4）MOV  AX，\[SI\]\[DI]       寻址方式错误
 (5）MOV  BYTE PTR [BX]，1000  1000超出值得范围(5以字节的形式传送给DS:BX)

25. 设要在地址为DAT1的数据区中顺次存放以下数据：’A’，’B’，0，0，’C’，’D’，0，0，写出分别用命令DB、DW和DD实现的语句。

26. 简述子程序与宏指令的区别。
    子程序：具有独立功能的程序模块。 
    宏指令：一个指令序列，汇编时产生对应的目标代码序列。
27. 说明RET，END，HLT的用途和区别.
    RET: 段内返回
    END 源程序结束伪指令
    HLT ；暂停 暂停指令停止软件的执行。有三种方式退出暂停：中断、硬件复位、
28.  执行下面的指令序列后，写出标志寄存器CF、PF、ZF、SF、OF位的状态。
```asm
MOV AX，35E5H
MOV BX, 7832H
ADD AX, BX
```
CF=0,PF=1,ZF=0,SF=1,OF=1

29. 阅读下列程序段，将执行结果填入后面的空格内。
```asm
MOV AX，BX
NOT AX
ADD AX，BX
INC AX
```
AX=0，CF=0
30. 说明下列指令中源操作数的寻址方式。

  (1) MOV  CX，24\[BX\][SI]   相对基址变址

  (2) MOV BX，[2000H] 直接寻址

  (3) INC  BYTE PTR[BX] 寄存器间接寻址

  (4) MOV  AX，[BP+DI] 基址变址


31. 解释PUSH DI指令是怎样工作的

  1. SP←SP-1，调整SP指针。
  2. 将DI内容的高8位压入堆栈指针SP所指的存储单元。
  3. SP←SP-1，调整SP指针。
  4. 将DI内容的低8位压入堆栈指针SP所指的存储单元。
32. 对于下面的数据定义，各条MOV指令单独执行后，AX寄存器的内容是什么？

```asm
ORG 2000H
A1  DB  ?
A2  DW  20 DUP(?)
A3  DB  'ABCD'
A4  DW  10 DUP(？)
(1) MOV  AX，TYPE A1    ;  
(2) MOV  AX，OFFSET A2  ;
(3) MOV  AX，LENGTH A3  ;
(4) MOV  AX，SIZE A4    ;
```

33. 伪指令的作用是什么？
    伪指令又称为操作，他们不像机器指令那样在程序运行期间由计算机来执行的，而是在汇编程序对源程序汇编是由汇编程序处理的操作。伪指令主要完成处理器选择、定义程序模式、定义数据、分配存储区、指示程序结束等功能。 
34. 标号的作用是什么？
    代码段中的名字字段叫做标号。它用来表示一个指令语句的符号地址，可以用该符号地址来访问该指令。
35. 假设VAR12和VAR34为字变量，LAB为标号，试指出下列指令的错误之处。

  1. ADD VAR12 ，VAR34;  ADD指令的源操作数和目的操作数不能同时为内存操作数，但VAR12和VAR34都是内存操作数。
  2. SUB AL ，VAR12;   VAR12是字变量，而AL是字节型的，不匹配
  3.  JMP LAB [DI] ;JMP 跳转指令，后面直接跟指令标号，所以不应该有[DI]..
  4.  JNZ VAR12 ;JNZ条件跳转指令，后面直接跟指令标号，但是VAR12 不是标号。

36. 试编写由键盘输入一个以回车（0x0D）作为结束的字符串，将其按ASCII码由大到小的顺序输出到显示器上的源程序。
```asm
DSEG  SEGMENT 'DATA'
RESULT DB 100 DUP(1)
N   DB 0
DSEG  ENDS
SSEG  SEGMENT STACK  'STACK'
DW   100H  DUP(?)
SSEG  ENDS
CSEG  SEGMENT 'CODE'
START  PROC  FAR
; STORE RETURN ADDRESS TO OS:
  PUSH  DS
  MOV   AX, 0
  PUSH  AX
; SET SEGMENT REGISTERS:
  MOV   AX, DSEG
  MOV   DS, AX
  MOV   ES, AX
;1.输入保存------------------------
  MOV CL, 0
  LEA SI, RESULT
input_next:
  MOV AH, 1
  INT 21H
  CMP AL, 0DH ; 回车为ODH
  JZ toSort
  MOV [SI],AL
  INC SI
  INC CL
  JMP input_next
toSort:
  MOV N, CL ;输入的ASCII码个数保存到N中
;2.排序--------------------
  MOV DH, 0
  MOV DL, N
  DEC DX
next1:  
  LEA BX, RESULT
  MOV CX,DX
next2:  
  MOV AL,[BX]
  CMP AL,[BX+1]
  JNC noX
  XCHG AL,[BX+1]
  MOV [BX],AL
noX:  INC BX
  LOOP next2
  DEC DX
  JNZ next1
;3.显示------------------
  MOV CH, 0
  MOV CL,N
  LEA BX, RESULT
displayNext:
  MOV DL,[BX]
  MOV AH,2
  INT 21H
  INC BX
  LOOP displayNext 
  RET
START  ENDP
CSEG  ENDS
END  START


```



37. 设从BUFFER开始存放若干个以$为结束标志的带符号字节数据，试编写将其中的正数按由大到小的顺序存入PLUS开始的缓冲区中的完整源程序。

（编程注意四个环节：段的定义；数据定义；提取带符号字节数据中的正数；由大到小排序。）

答：

```asm
DATA  SEGMENT

  BUFFER DB 11H,12H,0FEH,0EAH,32H,0A3H,22H,14H,54H,0C3H,09H,45H,53H,37H,38H,'$'

  PLUS  DB 15 DUP(0)

  STR   DB 0AH,0DH,"PLUS==>$"

DATA  ENDS

CODE  SEGMENT

  ASSUME   CS:CODE,DS:DATA

MAIN  PROC FAR

  MOV AX,DATA

  MOV DS,AX

  CALL SUB1 ; Calculate / Positive Number to PLUS

  CALL SUB2 ; Sort PLUS

  CALL SUB3 ; output PLUS / for testing the program

  MOV AH,4CH

  INT 21H

MAIN  ENDP

SUB1  PROC NEAR

  PUSH AX

  PUSH BX

  LEA SI,PLUS

  LEA BX,BUFFER

  XOR AX,AX

  XOR DX,DX

AA1:  MOV AL,[BX]

  CMP AL,24H

  JZ AA3

  TEST AL,80H

  JNZ AA2

  MOV [SI],AL

  INC SI

  INC BX

  INC DX ; total of PLUS

  JMP AA1

AA2:  INC BX

  JMP AA1

AA3:  POP BX

  POP AX

  RET

SUB1  ENDP

SUB2  PROC NEAR

  PUSH DX

  DEC DX

L1: MOV CX,DX

  LEA BX,PLUS

L2: MOV AL,[BX]

  CMP AL,[BX+1]

  JNC L3

  XCHG AL,[BX+1]

  MOV [BX],AL

L3: INC BX

  LOOP L2

  DEC DX

  JNZ L1

  POP DX

  RET

SUB2  ENDP

;;;;;;;;;;;;;;;;;;;;;;;;

SUB4  PROC NEAR

  PUSH AX

  PUSH CX

  PUSH DX

  MOV DL,[BX] ; BX is the Parameter in this function

  MOV CL,4

  SHR DL,CL

  OR DL,30H

  CMP DL,3AH

  JC BB1

  ADD DL,7

BB1:  MOV AH,2

  INT 21H

  MOV DL,[BX]

  AND DL,0FH

  OR DL,30H

  CMP DL,3AH

  JC BB2

  ADD DL,7

BB2:  MOV AH,2

  INT 21H

  MOV DL,48H

  INT 21H

  MOV DL,20H ;Output Space

  INT 21H

  POP DX

  POP CX

  POP AX

  RET

SUB4  ENDP

SUB3  PROC NEAR

  PUSH DX

  MOV CX,DX

  LEA DX,STR

  MOV AH,9

  INT 21H

  LEA BX,PLUS

LL1:  CALL SUB4

  INC BX

  LOOP LL1

  POP DX

  RET

SUB3  ENDP

CODE  ENDS

  END MAIN
```

38. 已知在ARRAY数组中有80个无符号字节数据，编写一个完整的8086汇编语言程序，将ARRAY数组中的最大值放入MAX单元中。

39. 有100个无符号整数，编写完整汇编程序，求最小值及其位置。

40.  有100个无符号整数，编写完整汇编程序，求平均值及其位置。

41. 说明计算机中采用Cache和虚拟存储器的原因。

Cache: CPU速度，主存容量

虚拟存储器: 主存速度,辅存容量

42. 段描述符用于描述段的信息，它由8个字节组成，保存段的属性、段的大小、段在存储器中的位置以 及控制和状态信息。 
43. Pentium实地址模式的特点，8086工作模式、Pentium实地址模式、Pentium虚拟8086模式之间的异同？
    Pentium实地址模式特点：能有效地使用8086所没有的寻址方式、32位寄存器和大部分指令。
    实地址方式，Pentium与8086兼容，基本体系结构相同。
    虚拟8086方式与实地址方式的不同： 
  * 虚拟8086方式是一个程序的运行方式。
  * 实地址方式是处理器的工作方式。

44. IDTR、GDTR和LDTR分别代表什么寄存器？其内容是什么信息？有什么作用？

  IDTR：中断描述符寄存器IDTR   48位=32位基地址(IDT起始地址)+16位界限
  IDT按字节计算大小，IDT最大可达64KB（但是Pentium 微处理机只能够支持256个中断和异常，最多占用2KB）。 • 中断描述符表IDT中存放的描述符类型均是门描述符。
  确认IDT存储位置和界限
  GDTR: 全局描述符表寄存器GDTR 48位=32位基地址(GDTR的起始地址) + 16位界限
  GDT保存的描述符类型：除中断门、陷阱门外的各类描述符。
  确认GDT存储位置和界限
  LDTR: 局部描述符表寄存器 指出LDT的基地址 
  16位选择符+(32位基址+20位界限+12位属性)
  确认LDT存储位置和界限
45. 说明段描述符的组成及作用。

8字节
  字节0   7-0 段界限
  字节1   15-8段界限
  字节2    段基址 7-0
  字节3    段基址15-8
  字节4    段基址23-16
  字节5    D7(P存在) D6D5(DPL特权级)D4(S分类)D3D2D1D0(TYPE类型)
  字节6    D7(G粒度) D6(D/B)D5(0)D4(AVL)D3D2D1D0(段界限19-16)
  字节7    段基址31-24
46. 说明CPL、RPL、DPL的含义。
  CPL是当前正在执行的代码段所具有的访问特权级。 
  RPL是新装入段寄存器的段选择符的特权级，存放在段选择符的最低两位 
  DPL是段被访问的特权级，保存在该段的段描述符的特权级DPL位。 
47. 任务状态段TSS的主要作用是什么？]
  任务切换
48. 简述Pentium通过GDT访问数据段的寻址过程（也可画图说明）。
49. 简述Pentium通过LDT访问数据段的寻址过程（也可画图说明）。
  看图就完事
50． 说明段页式存储管理的寻址过程。
  看图就完事
51． Pentium处理器采用分段存贮器管理时的数据访问逻辑地址转换为物理地址的过程。
  Pentium微处理器的分段存储管理机制允许将46位虚拟地址映射到硬件所需的32位物理地址。如图，首先由虚拟地址(逻辑地址)段选择符部分的13位索引字段确定段描述符在段描述符表中的位置，然后取出段描述符中的32位基地址并与逻辑地址中的32位偏移量相加，得到32位的线性地址。若无分页功能，则线性地址就直接是物理地址。

52. CPU与外部设备之间为什么要使用接口？
  微型计算机的外部设备多种多样，这些外设在工作原理、驱动方式、信息格式以及工作速度等方面彼此差别很大，它们不可能和CPU直接相连，必须借助于中间电路，即接口与CPU相连。
53. 什么是I/O接口? 什么是I/O端口？
  I/O接口是位于I/O设备与CPU（或系统总线）之间的电路；在微型计算机系统中，CPU与外部设备之间的联系，需要有特定的硬件连接和相应的控制软件。完成这一任务的软、硬件的综合称为接口。对这种硬件、软件的设计，称为接口技术。
  I/O端口是指接口电路中那些完成信息传送，可由程序寻址并进行读写操作的寄存器，是PC访问外设资源（通常是寄存器）的一种特定方式。
54.接口的基本功能是什么？
  对协定进行定义的引用类型。其他类型实现接口，以保证它们支持某些操作。接口指定必须由类提供的成员或实现它的其他接口。与类相似，接口可以包含方法、属性、索引器和事件作为成员。
55． 画出一个微型计算机I/O接口一般结构图，标明接口内部主要寄存器及外部主要信号线。
56． 计算机的I/O传送中，与程序查询传送和程序中断传送相比，DMA传送的主要优点是什么？
57． I/O接口有什么用途？
  I/O接口用来对CPU和外设的速度和工作方式进行匹配，协助完成CPU和外设之间数据传送和传送控制任务。其用途表现在以下几个方面：
  1. 地址译码或设备选择
    在微计算机系统中，可能有多个外部设备。当微处理器在不同时刻需要和不同的外部设备发生联系时，微处理器要用地址码来选择不同的外部设备。因此，接口必须进行地址译码，从而产生设备选择信号，以使微处理器和指定的外部设备交换信息。
  2. 数据缓冲和锁存
    在微计算机系统中，数据总线是系统各部分之间公用的双向总线，所有设备分时复用。所以，无论是存储器，还是外部设备，都不能长期占用数据总线，只允许被选中的设备在读/写周期内可用其传送数据。未选中的设备必须对总线呈高阻抗状态，与总线“脱离”，不影响其他设备使用总线。
  3. 信息格式与电平的转换
    在微计算机系统中，信息是并行二进制代码。CPU和内存的信息交换就采用并行处理。而有些外部设备，比如CRT显示器，其信息是串行数据，这就要求接口能把CPU输出的并行数据转换成串行数据，而把外部设备送来的串行数据转换成并行数据。此外，有些外部设备的信号电平与TTL电平不能兼容，所以还要有信号电平的转换。所以说，接口应该具有信号传送格式、信号类型、信号电平的转换能力。   
  4. 数据传送的协调
    CPU工作是有一定的时序的，CPU与外部设备交换数据时必须采用一定的传送方式进行控制。比如采用查询方式传送数据时，就要先询问外部设备是否已具备了与CPU交换数据的条件。具体地说，输入设备要给出“数据是否准备就绪”的状态信号。输出设备要给出“忙”或“闲置”的状态信号，由CPU决定是否可以进行数据交换。
58. 设置无条件输入端口的前提条件是什么?画图说明一个典型的无条件输入端口的组成?
  条件：输入设备可随时提供数据。
59. CPU与外设之间的数据传送控制方式。
  1. 程序查询方式：CPU通过查询I/O设备的状态，断定哪个设备需要服务，然后转入相应的服务程序。
  2. 程序中断方式：当I/O设备需要CPU为其服务时，可以发生中断请求信号INTR，CPU接到请求信号后，中断正在执行的程序，转去为该设备服务，服务完毕，返回原来 被中断的程序并继续执行。

 直接存储器存取（DMA）方式：采用这种方式时，在DMA控制器的管理下，I/O设备和存储器直接交换信息，而不需要CPU介入。

（4）I/O处理机方式：引入I/O处理机，全部的输入/输出操作由I/O处理机独立承担。

60. 说明DMAC8237的主要功能与特点。
  主要功能:
  1. 在一片8237A内有4个独立的DMA通道。
  2. 每个通道的DMA请求可分别编程允许或禁止。
  3. 每个通道的DMA请求有不同的中断优先级（即DMA操作优先权），优先级有两种：固定优先级和循环优先级，由编程决定。固定优先级的顺序是通道0最高，依次是通道1，通道2和通道3。
  4. 可在外设与存储器，存储器与存储器之间传送数据，存储器地址寄存器可以加1或减1。
  5. 可由软件编程改变DMA读写周期长度。
  6. 有四种工作方式：单字节传送方式，数据块传送方式，请求传送方式，级连方式。
  7. .可以多片级连，扩展通道数。
  8. DMA操作结束有两种方法：一是字节计数器减1由0变为FFFFH，二是外界通过输入负脉冲，强制DMA操作结束。
  9. DMA操作启动有两种方法：一是外设输入DMA请求信号DREQ，二是通过软件编程从内部启动。
  特点：
  1. 有4个独立的DMA通道，每个通道都充许开放或禁止DMA请求，都可以独立控制自动预置方式。
  2. 具有三种基本的传输方式：单字节传送、数据块传送、请求传送。
  3. 具有存储器到存储器的传送功能。
  4. 具有正常时序和压缩时序两种基本时序。
  5. 8257A级联可扩充任意个DMA通道。
  6. 有两种优先管理方式：固定优先级和循环优先级。
  7. 有较高的数据传输速率。

61. 说明8237A四种基本传送方式的特点。
  8237A有四种工作方式：单字节传送、数据块传送、请求传送和多片级联。
  1. 单字节传送方式的特点是：一次传送一个字节，效率较低，但它会保证在两次DMA传送之间，CPU有机会获得总线控制权，执行一次CPU总线周期。
  2. 数据块传送方式的特点是：一次请求传送一个数据块，效率高，但在整个DMA传送期间，CPU长时间无法控制总线（无法响应其他DMA请求，无法处理其他中断等）。
  3. 请求传送方式的特点是：DMA操作可由外设利用DREQ信号控制数据传送的过程。
  4. 级联方式的特点是：可扩展多个DMA通道。

62. 说明8237A三种传送类型。
  1. DMA读：8237A输出有效的MEMR和IOW信号，把存储器的数据读到I/0设备
  2. DMA写：8237A输出有效的MEMW和IOR信号，把I/0设备的数据写到存储器。
  3. DMA校验：实际上是校验8237A芯片内部的读写功能，也就是对读传输功能或写传输功能进行检验。

63. 说明8237A中正常时序、压缩时序、扩展时序的含义。
  正常时序：传送一个字节数据包含4个时钟脉冲周期，即S1-S4状态。产生的读写脉冲信号与这4个状态有确定的对应关系。若是数据块传送中不改变高8位地址，则省去S1，只占用S2、S3、S4三个时钟周期。
  压缩时序：把读命令的宽度压缩到等于写命令的宽度，省掉了S3，即由S4完成读和写的操作。
  在正常时序操作下，可选择扩展写方式，即写命令提前到读命令，从S3状态开始（一般情况下，读为S3、S4状态，写为S4一个状态）。

64. DMA控制器8237A的信号线IOW和IOR是单向的还是双向的？为什么？
  双向的
  主要原因是DMA8237既作主控者又作受控者.当做主控制器时，DMA控制器向地址总线传输地址，做受控者时，CPU向DMA控制器传输地址。

65. 说明8237A四种基本传送方式的特点。
  1. 单字节传送方式：8237A每次获得总线控制权后仅传送一个字节，传送之后修改通道 内当前地址寄存器和当前字节计数器内容，然后就释放系统总线。
  2. 数据块传送方式：8237A一旦获得总线控制权将连续传送完一个数据块，然后释放系统总线归还给CPU使用。
  3. 请求传送方式：与数据块传送方式类似，但要求在数据传送期间必须保持DREQ信号有效。每传送一个字节的数据后8237A都要采样DREQ，若DREQ无效，则停止DMA传送。
  4. 级联传送方式：从片的HRQ和HLDA引脚分别连接到主片的DREQ和DACK上，从片的优先级和所连主片通道的优先级相对应。这种情况下，主片的连接通道只起两个作用，一是优先级连接作用，即将从片的4个通道纳入到主片的优先级管理机制；二是向CPU输出HRQ和传递HLDA。

66. Pentium微处理机内部有哪几类中断？简要说明各类的特点是什么
  Pentium中断源分四类：可屏蔽中断（INTR）、非屏蔽中断（NMI）、软件中断（执行INTO、INT3、INT n、BOUND指令引起的中断）、异常

67. 什么叫中断向量？试说明Pentium微处理机可屏蔽硬件中断是怎样获得中断向量，从而进入中断程序的。
中断向量：中断服务程序的入口地址。
68. 中断描述符表的作用是什么？其内保存的是什么信息？
  中断描述符表是用来告诉处理器在遇到异常或 “INT”操作码时所应调用的中断服务例程。
  中断描述符表IDT：保存门描述符，整个系统一个，包括中断门、陷阱门、任务门（通常没有调用门）。

69. 说明8259A的中断优先权管理方式的特点。
  1. 完全嵌套方式（系统默认方式）：按固定优先级高低来管理中断，IR0最高，IR7最低，低级中断可被高级中断所中断，不响应同级中断
  2. 自动循环方式：中断源的中断优先级随着中断结束而改变的中断优先权管理方式。刚结束的中断源的中断优先级最低
  3. 特殊循环方式：类似于自动循环，不同的是在中断结束时发出特殊循环方式操作命令指定某个中断源的中断优先级最低
  4. 特殊屏蔽方式：在某些场合，希望能动态地改变中断优先结构，程序的某些部分要求禁止低级中断源的中断请求，但在高级中断服务处理过程中希望允许低级中断。
  5. 查询排序方式：这是一种用软件查询方法来响应与8259A相连接的8级中断请求的方式。
70. 说明8259A的中断结束方式的特点。
  此方式是在中断服务程序返回之前，向8259A发中断结束命令，使ISR中的相应位清零。1）非特殊EOI命令2）特殊EOI命令

71. 说明8259A中断控制器中的IRR、ISR和IMR三个寄存器的功能。
  I.RR是中断请求控制器。它保存从IR0-IR7来的中断请求信号。某一位有1就表示相应引脚上有中断请求信号。中断响应后，该IR输入线上的请求信号应该撤销。
  I.SR是中断服务寄存器。它用于保存正在服务的中断源。在中断响应时，判优电路把发出中断请求的中断源中优先级最高的中断源所对应的位设置为1，表示该中断源正在处理中。ISR某一位置1课阻止与它同级和更低优先级的请求被响应，但允许更高优先级的请求被响应。
  I.MR是中断屏蔽寄存器。它用于存放中断控制字，其中为1的位表示对应的中断请求输入将被屏蔽。
72. 8086发出INTA的条件是什么？
  当8086收到INTR的高电平信号时,在当前指令执行完且IF=1的条件下,8086在两个总线周期中分别发出INTA
73. 说明中断控制器8259A“特殊全嵌套方式”的含义和功能。
  适用于多片级连，且必须将优先级保存在各从片8259A中。 
  该方式与普通的全嵌套方式工作情况基本相同，区别在于两点： 
  1. 当某从片的一个中断请求被CPU响应后，该从片的中断仍未被禁止，即该从片中的高级中断仍可提出申请（全嵌套方式中这样的中断是被屏蔽的，因为这种中断对从片而言后者是高级中断，可以嵌套，但对主片而言，由于它们来自于同一个从片，故中断优先级相同，而在全嵌套方式中，同级和低级中断是被禁止的）。
  2. 在某个中断源退出中断服务程序之前，CPU要用软件检查它是否是这个从片中的唯一中断。

74. 简述Pentium CPU INTR的中断响应过程。
  Pentium要求可屏蔽中断请求信号是一个高电平信号，并且，INTR信号的高电平必须维持到CPU响应中断后才结束。
75. 试述8259A的初始化编程过程
  8259A的初始化命令字共有4个：ICW1--ICW4，进行初始化时要求按顺序写入ICW1-ICW4，根据ICW1的后两位确定是否写入ICW3和ICW4。
76. 中断响应有哪些条件？为什么CPU响应中断后立即关中断？
条件：
1）一条指令执行结束后。 2）有中断请求。 3）开中断。
其目的是在中断响应周期不允许其他同级的中断来打扰，以便能正确地转入相应的服务程序。
77. 中断响应周期主要完成哪些工作？这些工作是由硬件完成还是软件完成？
  中断处理（硬件完成）：关中断→保护现场（如标志）→ 保护断点→形成中断服务程序入口地址→转入中断服务程序。
  中断服务程序（软件完成） ：保护现场→中断处理→恢复现场→开中断→返回断点

78. 什么是外部中断？什么是内部中断？内部中断有什么特点？
外部中断也称为外部硬件实时中断，他由来自CPU某一引脚上的信号引起；内部中断也称软件指令中断，他是为了处理程序运行过程中发生的一些意外情况或调试程序而提供的中断
1. 内部中断由一条INT n指令直接产生，其中断类型号n或者包括在指令中，或者已由系统预先定义。
2. 除单步中断以外，所有内部中断都不能被屏蔽。 (3) 所有内部中断都没有中断响应 机器总线周期，这是因为内部中断不必通过查询外部来获得中断类型号。
79.  试简要说明中断服务程序的一般组成结构。

保护现场→中断处理→恢复现场→开中断→返回断点

80. 8259A中断类型码初始化控制字ICW2写入的是20H, 在8259A中断请求引脚IR1连接一个中断源， 其对应的中断服务程序名称为ISR_1（ISR_1从4000H:5678H开始分配内存地址）。画图说明从中断源，到中断向量表，再到中断服务程序的对应关系。
  因为8259A的IR1连接有一个中断源，当有中断时，自动填充中断类型码的低三位为001B,则对应的中断类型码为0010 0001B =21H，CPU在中断响应周期时取到中断类型码n = 21H，4n = 84H,到0000H段偏移为84H的位置取出中断服务程序ISR_1的入口地址4000H：5678H，跳到中断服务程序ISR_1去执行。

![img](file:///C:/Users/EndA/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png)

82. 8259A响应中断过程中会连续执行两个INTA中断响应周期，说明每个周期的功能是什么？
  第一个INTA中断响应周期：使IRR的锁存功能失效；使当前中断服务寄存器ISR中的相应位置1；使IRR寄存器中的相应位（即（2）中设置ISR为1所对应的IRR中的位）清0。
  第二个INTA中断响应周期：将中断类型码寄存器ICW2中的内容送到数据总线的D7-D0，即为CPU提供中断类型码；如果ICW4（方式控制字）中的中断自动结束位为1，那么，在第二个INTA负脉冲结束时，8259A会将第一个INTA负脉冲到来时设置的当前中断服务寄存器ISR的相应位清0。

83． 8259A的中断结束是指什么？简要说明8259A的3种中断结束方式的特点。
  使ISRx位清0的动作就是8259A的中断结束处理。
  包括：自动中断结束、一般中断结束命令和特殊中断结束命令。
  自动中断结束： 8259A在接收到第二个![img](file:///C:/Users/EndA/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png)响应信号的后沿自动清除ISRx。
一般中断结束命令用在全嵌套情况下。当CPU用输出指令往8259A发出一般中断结束命令时，8259A就会把当前中断服务寄存器中的最高的非零ISR位复位。

特殊中断结束命令用在非全嵌套方式下，特殊中断结束命令中带有用于指定ISR中要复位的三位（即L2～L0）编码信息,所以特殊中断结束命令可以作为任何优先级管理方式的中断结束命令。

83． 从方式名称、启动方法、计数值有效期限角度，说明8253的方式1与方式2的工作特点。

方式1是可重触发单稳态方式，由硬件启动，计数值多次有效，计数过程中输出保持为低，知道计数到0，OUT向高电平跳变。

方式2是脉冲发生器，有硬件和软件两种启动方式，计数值重复有效，OUT可以产生一个连续的波形。开始计数后当减到1时输出将变低一个时钟的宽度，然后恢复为高电平又重新计数。

84． 为什么对8253A写入计数值0是最大的计数值？在二进制计数方式下计数值相当于多少？如果8253A的时钟CLK频率为1.193MHz，工作在周期工作方式时，计算最大可以产生每秒多少次的周期信号（保留一位小数）？

因为8253A的OUT引脚是的计数器从1减少到0是有变化，设置计数值为0时，第一时钟到来时数值减1后变为65535，OUT引脚并不变化，则设置计数值为0则比65535还多一个，相当于65536.

取最大计数值65536， 则时钟为1.193MHz时， 在周期工作方式时，周期 = 1.193MHz/65536 = 18.2Hz

85． 用8253A产生5ms的周期信号，做为8259A中断请求输入，CLK=1MHz，分析8253A计数器需采用哪种工作方式，计数初值是多少。

86． 说明8253的方式2与方式3的工作特点。

87． 说明8253的方式1与方式5的工作特点。

88． 简述8253的主要特点。

89． 8253有几个通道？各采用几种工作方式？简述这些工作方式的特点。

90． 8253有几种读操作方式？简述之。

91． 在8253计数器的六种工作方式中，方式2和方式3各输出何种波形，它们有何特点。

92． 某系统中有一片8253，其计数器0至控制口地址依次为40H-43H，请按如下要求编程：

（1）通道0：方式3，CLK0＝2MHz，要求在0UT0输出1KHz方波。

（2）通道l：方式2，CLK1＝1MHz，要求OUT1输出1KHz脉冲波。

（3）通道2：方式4，CLK2＝OUT1，计数值为1000，计数到0时输出一个控制脉冲。

93． 某系统采用一片8253产生周期为2ms、个数为10的脉冲序列，已知有一个时钟源，频率为2MHz。要求：

（1）画出硬件接口电路图，并确定8253的端口地址。

（2）编写相应程序。

94． 画出8255工作于方式1输入的波形，并说明其工作过程。

95． 画出8255工作于方式1输出的波形，并说明其工作过程。

96． 并行接口芯片8255A的A口-控制口的端口地址依次为60H-63H。编一段程序使从PC5输出一个负脉冲。另外，若脉冲宽度不够，应如何解决。

97． 串行通信中为什么要用Modem？Modem在接收和发送中的作用是什么?

98． 简述FSK的调制原理。

99． 当串行通信的波特率是2400波特时，数据位时间周期是多少？

100． 简述异步通信和同步通信的主要区别。

101． 简述8251A初始化的一般步骤。

102． 串行异步通信字符格式中的停止位和空闲位有什么不同？

①停止位和空闲位都是高电平；

②停止位是字符格式中规定好的，是传递字符的一部分；（2分）

③两个互相通信的系统，在传输线上没有字符传送时是高电平。这个高电平称为空闲位。

103． 在串行异步通信中，为什么接收时时钟频率一般是波特率的16倍频？

104． 8251A可检测到几种接收数据错误，详细说明。

接收数据位奇偶校验不对，则标志有奇偶错误，在状态寄存器中PE会置1；CPU还没在把上一个接收的数据取走，下一个数据已经到来，则产生溢出错误，在状态寄存器中OE会置1；当没在检测到停止位时，产生帧错误，状态寄存器中的FE会置1。

105．  在8251A异步方式时，接收时钟RxC和发送时钟TxC都等于115200Hz，波特率因子为1，通信格式为115200、8、N、1，即波特率为115200、8个数据位、无奇偶校验位和一个停止位。计算每秒可以传送多少字节？ 并画出传送字符‘B’的帧格式。

115200/10 = 11520字节/s

![img](file:///C:/Users/EndA/AppData/Local/Temp/msohtmlclip1/01/clip_image012.png)

106． A/D和D/A转换器在微机应用中起什么作用？

在微机应用中A/D转换器完成输入模拟量到数字量的转换，供微机采集数据。D/A转换器完成微机输出数字量到模拟量的转换，实现微机控制。

107． 为什么DAC 0832特别适用于多个模拟量同时输出的场合？其工作过程如何？

①因为DAC0832有双缓冲结构。

②设有n个DAC0832接成双缓冲结构，一级缓冲地址不同，二级缓冲有相同地址，则先通过一级缓冲地址给每个DAC0832送入数据，最后使二级缓冲地址有效，同时转换。

108． 简述采样定理。

采样定理：对一个有 限频谱(ω <+ω max) 的连续信号进行采样， 当采样频率f≥2fmax 时（fmax是输入模拟 信号的最高频率）， 则采样输出信号能无 失真地恢复到原来的 连续信号。

 

109． 用CD4051设计一个32路模拟开关，画出电路连接图。

110． 采样/保持器有什么作用？

采样保持器在A/D转换接口中起着重要的模拟存贮器的作用。

 

采样保持器在A/D转换接口中起着重要的模拟存储器的作用。在对模拟信号进行采集与处理时，尽管A/D转换电路的速度很快，但是进行一次转换总需要一定的时间，在这一段时间内，要求被测信号保持不变，这就需要对被测信号进行采样和保持工作，采样保持在一个特定的时间上取出一个正在变化着的模拟信号的瞬时值，并把这个值保存下来，直到下次采样或数据处理结束为止。

111． 简述A/D转换的基本过程。

采样与量化是A/D转换的基本过程。采样是将模拟量变换为离散量，一般包括采样与保持两个步骤，量化是将离散量变换成数字量，一般包括量化与编码两个步骤。

112． ADC0809的输入电压=5V、参考电压=5V，当CPU接收到的ADC0809数字量为32时，外部输入到ADC0809的电压是多少伏。

5/256 = V/32 , V = 32*5/256 = 5/8 = 0.125V

113． A/D转换接口中采样保持电路的作用是什么？省略采样保持电路的前提条件是什么？

A/D转换接口中采样保持电路的作用是：能把一个时间边续的信号变换为时间离散的信号，并将采样信号保持一段时间。

114． 当外接模拟信号的变化速度相对于A/D转换速度来说足够慢，在转换期间可视为直流信号的情况下，可以省略采样保持电路。

115． PC/XT控制ADC0809构成一个压力参数采集系统，要求以查询方式采集400个压力值，存入ADBUF开始的存储单元，试设计硬件接口电路，并编写采集程序。

116． 采用8255A、ADC0809、DAC0832、8253和8088CPU构成一个数据采集控制系统，要求画出接口电路图，确定各芯片端口地址，说明系统工作原理。

117． DAC0832的参考电压=3V, 经过运算放大器后的输出电压范围为0～3V，若送到DAC0832的数字量是128，DAC0832输出电压是多少伏？

3/256 = V/128, V = 128*3/256 = 1.5V

118． DAC单极性输出，参考电压=5V，输出电压范围为0V～+5V。假设运行如下程序，试画出DAC输出的电压波型，并在图上标出最大峰值电压和周期值。

  org 100h

  mov dx, PORT_DAC ; DAC端口地址

 st:mov al, 0

 nxt:out dx, al

  inc al

  call delay_1ms ; 延时1毫秒

  cmp al, 80h

  jbe nxt

  jmp st

 ret 

峰值电压= 5V*80H/256 = 5V*128/256 = 2.5V

每个周期输出0到80H, 共129个值，每个周期约等于1ms, 则周期为129*1ms = 129ms

  ![img](file:///C:/Users/EndA/AppData/Local/Temp/msohtmlclip1/01/clip_image014.png)

119． DAC0832采用单极输出，参考电压=5V，输出电压最大值+5V。若输出2V的电压，需要写入DAC0832的数字量是多少？若输出250Hz方波，写入DAC0832的两个数字量之间的软件延时时间是多少？

120． 什么是键盘的行扫描法和线反转法？其实现过程有哪些区别？

行扫描法是步进扫描方式，行输出，列输入。每次输出的值中只有一位是0，其它都是1，每次输出的0位置是移动的，以低电平扫描行输出。

每扫描输出一行，同时通过检查列线的输入， 如果输入是全1，说明本行没有按键，则输出下一个行扫描值， 再进行检查列输入值，如果输入值不是全1， 则当前行扫描值对应的非0的行有按键，当前列值非0对应列有按键，由此时的行值和列值可以定出按键的位置。

线反转法是首先行输出列输入，之后反转为行输入列输出，行列输入输出要有可以改变方向的功能。首先行输出全0， 检查输入列值，如果是全1，则没有按键，如果不是全1，则保存读入的列值，之后反转行为输入列为输出，把上次读入的列值从列中输出，检查读入的行值并保存。由读入列值和反转后读入的行值可以确定按键的位置。

行扫描法只要求行输出，列输入，接口简单，但是软件复杂；线反转法要求接口具有方向可变功能，硬件复杂，而软件实现简单。

121． LED显示器的工作原理是什么？何谓共阳极？何谓共阴极？

LED显示器是用发光二极管显示字形的显示器件。在应用系统中通常使用的是七段显示器。七段显示器由七段组成，每一段是一个发光二极管，排成一个“日”字形。通过控制某几个发光二极管的导通发光而显示出某一字形，如数字0~9，字符A、B、C、D、E、F、P等。

为了能采用不同的驱动电路，一个七段显示器内部的七个发光二极管的连接有两种方法。一种叫共阴极接法，每个发光二极管的阴极接在一起，在使用中应将阴极接低电平，当某个发光管的阳极接高电平时，相应发光二极管就被点亮。另一种接法叫共阳极接法，即把所有发光管的阳极在内部连在一起，使用时应接高电平，当某个发光管的阴极接低电平时，相应发光二极管就亮。

 

122． LED显示器接口有哪几种方式？

①静态显示和动态显示。

②静态显示：当显示器显示某一个字符时，相应的发光二极管恒定地导通或截止。

③动态显示：一位一位地轮流点亮各位显示器，每位显示器隔段时间亮一次。

123． 设计一个通过8255A芯片控制的一个两位LED的动态显示接口电路。

124． 选用如下图给出的元器件设计一个恒温箱温度采集控制系统。该系统有两个状态：设置状态和控制状态。在设置状态时，通过键盘可以修改恒温箱的设定温度；在控制状态时，用开关量输出进行简单控制。检测温度与设定温度进行比较，当检测温度小于设定温度时，控制继电器加热；当检测温度大于设定温度时，关闭加热。当有按键时，发出1kHz声音，用于按键提示。

系统有两位七段数码管显示温度值（0~99℃）。在设置状态时，系统显示设定温度；在控制状态时，系统显示当前检测温度。系统通过4x4键盘输入设定温度值和启动控制，键盘有0~9键、Setting键和Control键共12个键可用。

（1）画出系统的硬件连接原理图，并标明分配给各元器件的端口地址。

（2）写出“0”对应的七段数码管译码值；编写8255、8253初始化程序；

（3）编写AD转换子程序（adc）、显示子程序（display）、按键识别子程序（key）和主程序（main）。

（1）硬件原理图如下

![img](file:///C:/Users/EndA/AppData/Local/Temp/msohtmlclip1/01/clip_image016.jpg)

![img](file:///C:/Users/EndA/AppData/Local/Temp/msohtmlclip1/01/clip_image018.jpg)![img](file:///C:/Users/EndA/AppData/Local/Temp/msohtmlclip1/01/clip_image020.jpg)

![img](file:///C:/Users/EndA/AppData/Local/Temp/msohtmlclip1/01/clip_image022.jpg)

![img](file:///C:/Users/EndA/AppData/Local/Temp/msohtmlclip1/01/clip_image024.jpg)

 

（2）写出“0”对应的七段数码管译码值；编写8255、8253初始化程序；

“0”对应的七段数码管译码值是：0C0H

 

;8255初始化

init_8255 proc near

  mov dx, PORT_CTR_8255

  mov al, 10001000b ;初始化8255控制字

  out dx, al

  ret

init_8255 endp

 

;8253_计数器0初始化---20ms中断请求

init_8253 proc near

  mov dx, PORT_CTR_8253

  mov al, 00110100b ;初始化8253控制字,计数0，r/w低8位 ,高8位，方式2，二进制计数

  out dx, al

  mov dx, PORT_COUNTER0_8253

  mov ax, 20000  ;计数常数 ; 20ms/(1/1Mhz) =20000

  out dx, al ;写低8位

  mov al, ah

  out dx, al ;写高8位

  ret

init_8253 endp

 

;开始发声，8253计数器1，方式3， 1kHz方波----

startBeep proc near

  mov dx, PORT_CTR_8253

  mov al, 01110110b ; 初始化8253控制字,计数1，r/w低8位 ,高8位，方式3，二进制计数

  out dx, al

  mov dx, PORT_COUNTER1_8253

  mov ax, 1000 ; 计数常数 ; 1mhz/1khz =1000

  out dx, al ; 写低8位

  mov al, ah ; 写8位

  out dx, al

  ret

startBeep endp

;----5.2停止发声，方式0----

stopBeep proc near

  mov dx, PORT_CTR_8253

  mov al, 01110000b ; 初始化8253控制字，计数1,方式0

  out dx, al

  ret

stopBeep endp

;----5.3发声100ms----

beep_200ms proc near

  push dx

  call startBeep

  delay 0ffh

  call stopBeep

  pop dx

  ret

beep_200ms endp

 

（3）编写AD转换子程序（adc）、显示子程序（display）、按键识别子程序（key）和主程序（main）。

Adc proc near

  ; 启动AD转换

  mov dx, PORT_START_0809  

  mov al, 0 

  out dx, al ;选择通道0

  mov is_adc_started, 1; 下次是查询状态

 sample_ch0:

  ; 查询转换结束引脚eoc，非阻塞方式

  mov dx, PORT_EOC_0809

  in al, dx

  test al, 00000001b ;eoc引脚为高电平？

  jz exit_isr  

  ;eoc变高到此，输入adc转换结束数值

  mov dx, PORT_DATA_0809

  in al, dx 

  mov [sample_ch0_val], al; 保存AIN0采集数字量

  mov is_adc_started, 0 ; 下次是启动AD状态

  call calc_ad2tmp; 计算当前温度值

 exit_isr: 

ret

Adc endp

 

display proc far  

  push ax

  push bx

  push cx

  mov bx, offset led_table

  cmp is_in_control_state, 1

  je get_cur_tmp_val

  mov cl, setting_tmp_val

  jmp start_display

 get_cur_tmp_val:  

  mov cl, sample_tmp_val  

 start_display: 

  mov al, 0

to_w10:  

  cmp cl, 10

  jb display_w10

  inc  al

  sub cl, 10

  jmp to_w10

  …

  cmp is_on_heatting_state, 1; 在加热时

  je on_heatting

  and al, 01111111b 

  jmp out_w1

 on_heatting:

  or al, 10000000b 

 out_w1: 

  mov dx, PORT_B_8255

  out dx, al ;显示个位 

  pop cx

  pop bx

  pop ax

  ret

display endp

 

 

key_identify proc near   

  ;(1)判断是否有键按下

  mov dx, PORT_C_8255

  mov al,0

  out dx, al; PC3~0行输出全0

  nop

  in al, dx ;读入列值PC7~4

  and al, 11110000b

   cmp al, 11110000b

  jne re_confident

  mov is_new_key, 0; 无新键值

  jmp error_exit 

  ;(2)有键按下，软延时，再次判断

 re_confident: 

  delay 0ffh

  in al, dx ;读入列值PC7~4

  and al, 11110000b

  cmp al, 11110000b

  jne has_key

  mov is_new_key, 0; 无新键值

  jmp error_exit 

  ;(3)识别按键。确实有键按下，开始扫描，

 has_key:

  mov ah, 11111110b

  mov cx,4

 scan_next_row:

  mov al, ah

  out dx, al

  nop 

  in al, dx

  and al, 11110000b

  cmp al, 11110000b

  jne find_key ; 行值ah, 列值al 

  rol ah, 1

  loop scan_next_row

  jmp error_exit

 find_key:

  and ah, 00001111b

  mov cl,4

  shr al, cl

  ; 计算键位值，行值ah, 列值al 

  ;计算行计数值

  …

  mov ah, bl ; 保存行计数值ah

  ;计算列计数值

  mov bl, -1 ;计数0位置

  mov cx, 4

 next_column:

  inc bl; 列号计数

  shr al, 1

  jnc find_column

  loop next_column

  mov is_new_key, 0; 无新键值

  jmp error_exit 

 find_column:

  mov al, bl;保存列计数值al

  shl ah, 1

  shl ah, 1; x4

  add al, ah ;al键位置值

  mov cur_key, al; 保存当前键值

  mov is_new_key, 1; ***有新键值

  call beep_200ms;发声

  ;(4)判断是否键释放，行输出全0

no_release_wait:

  mov al, 0

  out dx, al ; PC7~4列输入，PC3~0 行输出

  nop 

  in al, dx; 读入行值   

  and al, 11110000b

  cmp al, 11110000b

  jne no_release_wait  

  delay 0ffh ;键释放，软延时  

 error_exit: 

  ret

key_identify endp

 

main:  

  ;----(0)初始化 

  call init_vct_table ;中断时用

  call init_8255 ;8255A初始化;!!!初始化8255时，端口数据消失

  call init_8253 ;中断时不用

  call init_8259 ;仿真时不用

  call display 

  ; --->转到两个状态

 main_loop:   

  cmp is_in_control_state, 1

  …  

 ;----(1)设置状态---------------

 loop_in_setting_state: 

  call key_identify;识别按键

  cmp is_new_key, 1

  jne loop_in_setting_state

  cmp cur_key, 0Bh; 0Bh,进入控制状态

  je change2control_state

  …

  jmp main_loop

  

 ;----(2)控制状态-----------

 loop_in_control_state:  

  call key_identify

  cmp cur_key, 0AH; 0AH,设置按键  

  je change2setting_state; 转到设置状态  

  …

  call display 

  jmp main_loop  

  ret

 

 

 

 

 

 

 

 
